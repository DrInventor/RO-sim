<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>41fd7b4bbda4ffeea48c3189c9c336cc309391988a1f28ce1389d3f0a6c5e0a4</job>
    <base_name>3wxs</base_name>
    <doi>http://dx.doi.org/10.1111/j.1467-8659.2005.00841.x</doi>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <title-group>
        <article-title class="DoCO:Title" id="2">
        	<s id="1" sid="1">A Data-driven Approach for Real-Time Clothes Simulation</s>
        </article-title>
      </title-group>
      <contrib-group class="DoCO:ListOfAuthors">
        <contrib contrib-type="author">
          <name id="3">Frederic Cordier</name>
        </contrib>
        <contrib contrib-type="author">
          <name id="4">Nadia Magnenat-Thalmann</name>
        </contrib>
      </contrib-group>
      <region class="unknown" id="6">MIRALab, University of Geneva, 24 rue du General Dufour, CH-1211 Geneva, Switzerland {cordier, <email id="5">thalmann}@miralab.unige.ch</email></region>
      <abstract class="DoCO:Abstract" id="12"><s id="7" sid="2">A data-driven approach for real-time processing of clothes, particularly suitable for simulating dresses worn by virtual characters, is proposed.</s><s id="8" sid="3"> It starts, prior to real- time simulation, by analyzing cloth behavior in relation to the underlying skeleton movement from a pre-simulated sequence of the cloth obtained using any high quality off- line simulators.</s><s id="9" sid="4"> The idea is to use this analysis to find an optimal combination of physics-based simulation and geometric approximation of the simulator; potentially colliding regions are defined on the cloth such that they will hold true for the skeleton movement that closely matches that of pre-simulated sequence.</s><s id="10" sid="5"> At runtime, using these analyses, our simulation process provides both visually pleasing results and performance, as long as the motion of the character remains sufficiently close to the original sequence used for the pre-computation.</s><s id="11" sid="6"> The key contributions of this paper are (1) efficient collision handling that prunes out potentially colliding objects by using the off-line simulation sequence as examples; (2) data-driven fix-up process for the coarse mesh simulation that deduces the gross behavior of the cloth; and (3) geometric approximation of the fine mesh deformation, responsible for details in the shape of the cloth such as wrinkles.</s></abstract>
    </front>
    <body class="DoCO:BodyMatter">
      <section class="deo:Introduction">
        <h1 class="DoCO:SectionTitle" id="13" page="1" column="1">1. Introduction</h1>
      </section>
      <region class="DoCO:TextChunk" id="39" page="1" column="1"><s id="14" sid="7">The problem of simulating the behavior of clothes is one subject the graphics community has been grappling with since almost two decades ago [19] [21].</s><s id="15" sid="8"> Relatively little emphasis has been placed on the separate problem of how to achieve real-time performance in simulating cloth.</s><s id="16" sid="9"> A number of strategies have been suggested, such as using simplifying assumptions for the physics model and/or collision detection [<xref ref-type="bibr" rid="R7" id="17" class="deo:Reference">7</xref>] [12].</s><s id="18" sid="10"> A recent work by James et al.</s><s id="19" sid="11"> [10] suggests a different approach by adopting a data-driven method.</s><s id="20" sid="12"> These techniques do not suffice, however, when simulating fully dressed virtual characters in real-time, leaving the topic unexplored.</s><s id="21" sid="13"> We present a data-driven method for simulating clothes worn by 3D characters in real-time.</s><s id="22" sid="14"> To effectively optimize the physics-based deformation, which is the bottleneck of the simulation, we use a coarse<marker type="column" number="2"/><marker type="block"/> representation of the cloth mesh to drive the gross behavior in simulation.</s><s id="24" sid="15"> We consider that the gross cloth behavior is driven mainly by two separable contributions: the skeleton-driven movement of the character and the mechanical properties of the cloth.</s><s id="25" sid="16"> This consideration was partly inspired by the hybrid real-time simulation method proposed in Cordier et al.</s><s id="26" sid="17"> [<xref ref-type="bibr" rid="R5" id="27" class="deo:Reference">5</xref>], where a hybrid deformation method is used to combine dynamic surfaces with Skeleton-Driven Deformation (SDD).</s><s id="28" sid="18"> Unlike that method, however, our method exhibits significantly more efficient and realistic behavior.</s><s id="29" sid="19"> This effect is achieved by focusing on the analysis of cloth movements in relation to its associated skin surface, and adopting a learning strategy.</s><s id="30" sid="20"> The idea is to use the analysis of the pre- simulated sequence to identify the region largely explained by joint movement and to replace the physics based simulation with geometric methods wherever possible.</s><s id="31" sid="21"> In our approach, the key ingredients of the new technique are associated with different facets of cloth simulation: First, our novel collision detection prunes out unnecessary collision tests by tightly localizing potentially colliding regions through the analysis of the cloth movement in relation to the skeleton.</s><s id="32" sid="22"> Second, we use the pre-simulated sequence to approximate the dynamic behavior of the coarse mesh geometrically wherever possible.</s><s id="33" sid="23"> Finally, fine details such as wrinkles are also simulated in a data-driven manner, by using the pre-simulated cloth sequence as examples.</s><s id="34" sid="24"> Subsequently, real-time animation of fully dressed human could be generated, which would be suitable for applications such as games where visual plausibility is more important than accuracy.</s><s id="35" sid="25"> The remainder of this paper is organized as follows: We begin by reviewing previous approaches in Section 2.</s><s id="36" sid="26"> Section 3 gives an overview, followed by the description of our method for SDD in the Section 4.</s><s id="37" sid="27"> The next two sections are dedicated to the simulation of gross behavior and the generation of wrinkles, respectively.</s><s id="38" sid="28"> After demonstrating results and performance in Section 7, we conclude with discussion and future work in Section 8.</s></region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="40" page="1" column="2">2. Previous Work</h1>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="45" page="2" column="1">2.1. Numerical solvers</h2>
          <region class="DoCO:TextChunk" id="77" page="2" column="1"><s id="46" sid="29">Probably the most common technique for simulating the physical properties of clothes is the particle system.</s><s id="47" sid="30"> Simulation process is broken down into calculating the internal forces and solving the system of Partial Differential Equations (PDE).</s><s id="48" sid="31"> The latter point has attracted much interest in the field of real-time applications, since it requires high computation power.</s><s id="49" sid="32"> The explicit Euler method [<xref ref-type="bibr" rid="R2" id="50" class="deo:Reference">2</xref>] has been one of the first numerical solvers.</s><s id="51" sid="33"> Unfortunately, this method is notorious for its instability when using large time steps and stiff equations.</s><s id="52" sid="34"> Several improvements have been proposed to reduce instability, such as the Verlet integration [11] and the explicit Euler combined with inverse dynamics [17] [20].</s><s id="53" sid="35"> Unfortunately, the simulation quality is sacrificed in favor of computation speed, due to the approximations employed in these models.</s><s id="54" sid="36"> The implicit Euler method presented by Baraff et al.</s><s id="55" sid="37"> [<xref ref-type="bibr" rid="R2" id="56" class="deo:Reference">2</xref>] performs the computation not by using the derivative at the current time, but the predicted derivative at the next time step.</s><s id="57" sid="38"> Unlike explicit Euler integration, the implicit Euler method offers higher stability while using large time-steps and clothes with stiff mechanical properties.</s><s id="58" sid="39"> A major drawback of this numerical solver, however, is the computation of a large linear system, More recently, researchers worked on saving the computation time of the linear system solver.</s><s id="59" sid="40"> Desbrun et al [<xref ref-type="bibr" rid="R7" id="60" class="deo:Reference">7</xref>] proposed solving the linear system with a pre- computed inverse matrix.</s><s id="61" sid="41"> Kang et al.</s><s id="62" sid="42"> [12] proposed further optimization with a direct update formula for the positions and velocities of the cloth vertices.</s><s id="63" sid="43"> As indicated by the authors, these methods are not intended to provide a physically-correct cloth animation.</s><s id="64" sid="44"> Our approach to that problem is a data-driven mass-spring system: the simulation is corrected with a set of functions built from the pre-simulated animation.</s><s id="65" sid="45"> By doing so, we bring the deformation of the mass-spring system closer to the original cloth behavior.</s><s id="66" sid="46"> Another approach to fast garment deformations is the hybrid approach.</s><s id="67" sid="47"> They aim for a neat combination of physically based deformation and geometric deformation.</s><s id="68" sid="48"> Cordier et al.</s><s id="69" sid="49"> [<xref ref-type="bibr" rid="R5" id="70" class="deo:Reference">5</xref>] proposed to segment the cloth into pieces and simulate these by different algorithms, depending on how they lie on the body surface and whether they adhere to it or flow over it.</s><s id="71" sid="50"> Others have noted that wrinkle deformation is geometric in nature and therefore can be computed with a geometric method.</s><s id="72" sid="51"> Wrinkles can be generated either by tessellating the cloth mesh [12] or rendering details on texture using bump mapping [9].</s><s id="73" sid="52"> The main difficulty is defining a fold function that can simulate all kinds of wrinkle patterns.</s><marker type="column" number="2"/><marker type="block"/> <s id="75" sid="53">Moreover, determining the location and shape of wrinkles is left to CG artists.</s><s id="76" sid="54"> One of our contributions is a geometric wrinkling method that is “trained” by using a pre-simulated cloth sequence, rather than relying on users.</s></region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="78" page="2" column="2">2.2. Collision handling</h2>
          <region class="DoCO:TextChunk" id="85" page="2" column="2"><s id="79" sid="55">Collision detection is usually one of the bottlenecks in real-time animation.</s><s id="80" sid="56"> The problem is particularly acute in the case of clothes because these objects are highly deformable.</s><s id="81" sid="57"> Several algorithms have been proposed to process robustly collisions in cloth simulation [21] [22] without reaching real-time performance.</s><s id="82" sid="58"> Some other methods exploit graphics hardware to compute collisions on bump maps [20]; others use implicit surfaces to check collisions on the body [18], or voxel trees, which partition the space hierarchically [14].</s><s id="83" sid="59"> Using frame coherency to reduce computation cost has been explored by Zhang et al [23].</s><s id="84" sid="60"> In this work, we propose a data-driven collision detection method; we use the pre-simulated sequence to localize the collision checks to neighboring cloth regions that have high probability to collide.</s></region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="86" page="2" column="2">2.3. Data-driven approaches</h2>
          <region class="DoCO:TextChunk" id="96" page="2" column="2"><s id="87" sid="61">The idea of building an interpolator from examples or pre-simulated data has proven to be a valuable tool in a variety of areas of CG, e.g.</s><s id="88" sid="62"> for modeling a variety of human body shapes and for motion synthesis.</s><s id="89" sid="63"> The basic idea is to build an interpolation space filled with a set of pairs of input parameters and the targeted graphical objects.</s><s id="90" sid="64"> Cloth animation depends on a high number of parameters and therefore a data-driven approach is difficult to adapt.</s><s id="91" sid="65"> Very recently, James et al.</s><s id="92" sid="66"> [10] resented such an approach, where physics-based deformation and collision detection are both handled in a unified framework.</s><s id="93" sid="67"> By blending of pre-computed orbits rather than using a mass-spring system, previous unseen results could be achieved, such as garments with stiff mechanical properties in real-time.</s><s id="94" sid="68"> However, they show little degrees of freedom (DoF) to the clothes under simulation; Instead of resorting to a data-driven approach for the entire simulation, we seek a neat combination of a data-driven approach with the mass-spring system.</s><s id="95" sid="69"> Unlike previous works, our simulator allows a much higher degree of interaction, as it is often needed in animating clothes on moving characters.</s></region>
        </section>
      </section>
      <region class="DoCO:TextChunk" id="44" page="1" column="2"><s id="41" sid="70">The history of research on real-time cloth is relatively recent.</s><s id="42" sid="71"> Researchers have concentrated mainly on two<marker type="page" number="2"/><marker type="column" number="1"/><marker type="block"/> aspects of real-time cloth animation: simulating the physical properties of garments and collision handling.</s></region>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="97" page="2" column="2">3. Overview of our approach</h1>
        <region class="DoCO:TextChunk" id="104" page="2" column="2"><s id="98" sid="72">The primary focus of this paper is the development of a fast cloth simulator for real-time applications.</s><s id="99" sid="73"> Dynamic simulation of complex deformable models, however, can<marker type="page" number="3"/><marker type="column" number="1"/><marker type="block"/> easily involve thousands of degrees of freedom.</s><s id="101" sid="74"> For example, a physics-based simulator would require several minutes to compute one frame of a cloth model worn by a character.</s><s id="102" sid="75"> Simulating large models directly would therefore be computationally impractical.</s><s id="103" sid="76"> In what follows, we present the chosen optimization strategies as well as the workflow of the method.</s></region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="105" page="3" column="1">3.1. Optimization strategies</h2>
          <region class="DoCO:TextChunk" id="123" page="3" column="1"><s id="106" sid="77"> <xref ref-type="fig" rid="F1" id="107" class="deo:Reference">Figure 1</xref> summarizes our strategies for optimizing the cloth simulation.</s><s id="108" sid="78"> Our simulator is based on two levels of deformation: the first deduces the gross cloth behavior by working on a coarse mesh with a physics-based approach whereas the second generates wrinkles on a fine mesh with a geometric method.</s><s id="109" sid="79"> The coarse mesh is generated by simplifying the original cloth mesh through segmentation.</s><s id="110" sid="80"> The reason for this choice is to lower the computation time; geometric methods are in general much faster than physically-based ones [9].</s><s id="111" sid="81"> Simulation stages Strategies to reduce the computation time Simulating the - Simplified mass-spring system gross movements - Implicit Euler integrator on the coarse mesh - Post-correction to maintain the cloth behaviour closer to the pre-simulated one Collision detection - Each vertex is enclosed into a collision hull on the coarse mesh that is rigidly attached to the skeleton - Extra collision detection is also computed between the floating regions and the skeleton joints Modelling the cloth - Geometric deformation with a linear function details on the fine which coefficients are defined by linear mesh regression on the pre-simulated animation<marker type="block"/> Next, our simulator assumes that the clothes are worn on 3D characters, and that the character movement is the only external force acting upon the cloth.</s><s id="116" sid="82"> When observing the behavior of garment worn by a character, there are considerable correlations between the body motion and the movement of the garment.</s><s id="117" sid="83"> These correlations are especially clear for some clothes like tight shirts and trousers.</s><s id="118" sid="84"> In our method we take advantage of these relationships to reduce the computation load on the mass-spring system and collision detection.</s><s id="119" sid="85"> We first construct the cloth-to-joint relation by analyzing a pre- simulated sequence of the cloth to be animated.</s><s id="120" sid="86"> We then reduce the number of vertices to be physically simulated by identifying the garment regions in which the shape follows that of the underlying skin.</s><s id="121" sid="87"> The cloth-to-joint relation enables us also to optimize collision detection by restricting the collision check to a small area around each vertex of the coarse mesh.</s><s id="122" sid="88"> Finally, we use the cloth shape of a pre-simulated cloth sequence to correct the physics- based simulation of the coarse mesh in order to match the original cloth behavior more closely.</s></region>
          <region class="DoCO:FigureBox" id="F1">
            <caption class="deo:Caption" id="115" page="3" column="1"><s id="113" sid="89">Figure 1.</s><s id="114" sid="90"> The chosen strategies to save computation time.</s></caption>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="124" page="3" column="2">3.2. Workflow</h2>
          <region class="DoCO:TextChunk" id="136" page="3" column="2"><s id="125" sid="91">An overview of the workflow is given in <xref ref-type="fig" rid="F2" id="126" class="deo:Reference">Figure 2</xref>.</s><s id="127" sid="92"> The pre-processing stage involves generating the coarse mesh, computing the cloth-to-joint relation, and constructing the collision hulls and the interpolation functions for data-driven coarse mesh deformation and wrinkle animation.</s><s id="128" sid="93"> Global movements Cloth details (Section 5) (Section 6) Pre-simulated Cloth Animation Sequence Pre-processing Cloth-to-joint Pre-processing relation of the Coarse Coarse Mesh of Pre-processing the Fine Mesh Collision Hulls Mesh Coefficients of the Structure wrinkle interpolator Simulation Detection Collision Data-driven Spring System Mass- Wrinkle Shape Skeleton Coarse Mesh Interpolator Runtime Animation Geometry Fine Mesh Geometry<marker type="block"/> The run-time simulator includes deformation of the coarse mesh using the simplified mass-spring system; a post-correction on the position and velocity of the mass- points is processed in order to approach the pre-simulated cloth behavior.</s><s id="134" sid="94"> Collisions are handled by collision hulls the position of which is computed by our SDD.</s><s id="135" sid="95"> The final mesh is then obtained using the winkle shape interpolator and the computed geometry of the coarse mesh.</s></region>
          <region class="unknown" id="130" page="3" column="2">Data Process</region>
          <region class="DoCO:FigureBox" id="F2">
            <caption class="deo:Caption" id="133" page="3" column="2"><s id="131" sid="96">Figure 2.</s><s id="132" sid="97"> Workflow of our approach.</s></caption>
          </region>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="137" page="3" column="2">4. Improving the skeleton driven deformation</h1>
        <region class="DoCO:TextChunk" id="159" page="3" column="2"><s id="138" sid="98">The skeleton-driven deformation (SDD), a classical method for the basic skin deformation is perhaps the most widely used technique in 3D character animation.</s><s id="139" sid="99"> This method works first by assigning a set of joints with weights to each vertex in the character.</s><s id="140" sid="100"> The location of a vertex is then calculated by a weighted combination of the transformation of the influencing joints.</s><s id="141" sid="101"> Although developing a new SDD method is not our main goal, the way the skin deforms is important in our framework since natural looking cloth shape also requires natural skin shape.</s><s id="142" sid="102"> There are two requirements which the method should fulfill for this particular use: first, it must overcome the undesirable effect of vertex collapse as shown in <xref ref-type="fig" rid="F3(a)" id="143" class="deo:Reference">Figure 3(a)</xref>.</s><s id="144" sid="103"> Second, the method must provide an easy way to compute the local coordinate system for<marker type="page" number="4"/><marker type="column" number="1"/><marker type="block"/> each skin vertex.</s><s id="146" sid="104"> This is necessary as we want to compute the deformation of the cloth surface in relation to the skin surface.</s><s id="147" sid="105"> We found that the classical SDD can be greatly improved by replacing the linear combination of the matrices by the matrix operator defined by Alexa [<xref ref-type="bibr" rid="R1" id="148" class="deo:Reference">1</xref>].</s><s id="149" sid="106"> The combination of i matrices Mi with their blending weight w i is given by: ∑ w i log( M i ) M SSD = ⊕ w i ⋅ M i = e i i In the remainder of this paper, we denote the function that returns the SDD matrix of the vertex P by SDD P (), SDD P () taking the joint angles of the skeleton as input.</s><s id="150" sid="107"> The SDD position of P is simply given by M SDD .X P,Dress , X P,Dress being the position of P at initial character pose (see [15] for further details on SDD).</s><marker type="block"/> <s id="156" sid="108">Note that the operator is not continuous.</s><s id="157" sid="109"> It is not defined for a rotation of 2π radians between the matrices to be blended.</s><s id="158" sid="110"> In practice, such case is rare; in general, the largest angle range does not exceed π radians.</s></region>
        <region class="DoCO:FigureBox" id="F3">
          <image class="DoCO:Figure" src="3wxs.page_004.image_01.png" thmb="3wxs.page_004.image_01-thumb.png"/>
          <image class="DoCO:Figure" src="3wxs.page_004.image_02.png" thmb="3wxs.page_004.image_02-thumb.png"/>
          <image class="DoCO:Figure" src="3wxs.page_004.image_03.png" thmb="3wxs.page_004.image_03-thumb.png"/>
          <image class="DoCO:Figure" src="3wxs.page_004.image_04.png" thmb="3wxs.page_004.image_04-thumb.png"/>
          <caption class="deo:Caption" id="155" page="4" column="1"><s id="153" sid="111">Figure 3.</s><s id="154" sid="112"> Twisting of 2⁄3 π radians: (a) the classical SDD, (b) the modified SDD in our approach and (c) its corresponding coordinate systems.</s></caption>
        </region>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="160" page="4" column="1">5. Simulation of the gross behavior</h1>
        <region class="DoCO:TextChunk" id="166" page="4" column="1"><s id="161" sid="113">Due to the computational expenses of solving the full numerical system of the physics-based deformation, we seek simplifications by constructing a coarse mesh representation of the garment.</s><s id="162" sid="114"> The coarse mesh is used to deduce the gross behavior of the cloth in a data-driven manner, based on the input pre-simulated sequence.</s><s id="163" sid="115"> A number of optimization strategies are adopted: The two following sections describe a preprocessing that constructs and segments a coarse mesh representation into different region types.</s><s id="164" sid="116"> We then describe in the next two sections the spring-mass system and collision handling of the coarse mesh at each frame of the simulation.</s><s id="165" sid="117"> Also described is the runtime process.</s></region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="167" page="4" column="1">5.1. Construction of the coarse mesh ∈</h2>
          <region class="DoCO:TextChunk" id="197" page="4" column="1"><s id="168" sid="118">We begin by constructing a coarse representation of the given cloth model that will drive the gross behavior of the simulated garment.</s><s id="169" sid="119"> It consists of two following steps: (1) The cloth surface is partitioned into a set of patches as shown in <xref ref-type="fig" rid="F4(a)" id="170" class="deo:Reference">Figure 4(a)</xref> and (b).</s><s id="171" sid="120"> (2) A coarse mesh<marker type="column" number="2"/><marker type="block"/> representation is obtained by combining a set of vertices in a patch into a single mass point located at the center.</s><s id="173" sid="121"> The generation of a patch starts by finding a vertex that has not yet been attributed to a patch that is already generated.</s><s id="174" sid="122"> The patch is then grown by adding neighboring vertices one after the other.</s><s id="175" sid="123"> To select a new vertex into the current patch, we evaluate each neighboring vertex that has not been already assigned to a patch, using a penalty function.</s><s id="176" sid="124"> To enforce the regularity of coarse mesh, which is one condition for obtaining efficient deformation with the mass-spring system [21], we consider two following components.</s><s id="177" sid="125"> • Minimizing the "shape factor": Square Root (Surface Area)/Contour Length.</s><s id="178" sid="126"> The objective is to obtain "well-shaped patches", patches that have a circular shape.</s><s id="179" sid="127"> • Obtaining patches of equivalent surface area.</s><s id="180" sid="128"> This component gives a cost that increases with the surface area of the patch.</s><s id="181" sid="129"> By modifying the significance of this component, we can easily control the number of vertices to be simulated with the physically-based deformation (see <xref ref-type="fig" rid="F4" id="182" class="deo:Reference">Figure 4</xref>).</s><s id="183" sid="130"> The vertex with the lowest cost is selected.</s><s id="184" sid="131"> When the lowest cost exceeds a threshold, the construction of the patch is completed.</s><s id="185" sid="132"> We proceed until no vertices can be found to start a new patch.</s><s id="186" sid="133"> Deciding a good granularity in the coarse mesh is hand-tuned, so that a neat compromise between the simulation quality and the computation load is found.</s><s id="187" sid="134"> We have found that best simulations are obtained when patch area covers one or two cloth wrinkles.</s><marker type="block"/> <s id="195" sid="135">Note that that each patch is associated with a vertex on the coarse mesh.</s><s id="196" sid="136"> We denote the vector position of a vertex P as XP, and the vector position of its neighbors as X N R 3n (n: number of neighbors of P).</s></region>
          <region class="DoCO:FigureBox" id="F4">
            <image class="DoCO:Figure" src="3wxs.page_004.image_05.png" thmb="3wxs.page_004.image_05-thumb.png"/>
            <image class="DoCO:Figure" src="3wxs.page_004.image_06.png" thmb="3wxs.page_004.image_06-thumb.png"/>
            <image class="DoCO:Figure" src="3wxs.page_004.image_07.png" thmb="3wxs.page_004.image_07-thumb.png"/>
            <caption class="deo:Caption" id="194" page="4" column="2"><s id="190" sid="137">Figure 4.</s><s id="191" sid="138"> Two examples of segmentation with (a) patches of large (260 cm2), and (b) small surface area (95 cm2).</s><s id="192" sid="139"> (c) is the coarse mesh corresponding to the segmentation (b).</s><s id="193" sid="140"> Different colors are randomly assigned to the patches.</s></caption>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="198" page="5" column="1">5.2. Identifying cloth-to-joint relations and region types</h2>
          <region class="DoCO:TextChunk" id="239" page="5" column="1"><s id="199" sid="141">Next we carry out cloth-to-skin (or body) attachment through skin fitting, by which the skinning data on the cloth mesh are approximated in such a way that the skinning-driven cloth shape best fits the simulated cloth shape throughout the whole pre-simulated sequence.</s><s id="200" sid="142"> The basic idea is to use the pre-simulated results as examples and find the error-minimizing skin data through optimization.</s><s id="201" sid="143"> An optimization approach, such as the one presented by Mohr et al [15], could be adopted here.</s><s id="202" sid="144"> In our case, however, our SDD method is non-linear and therefore the linear regression as adopted by Mohr et al is not beneficial.</s><s id="203" sid="145"> Function minimization techniques such as Powell’s method [16] can deal with non-linear functions.</s><s id="204" sid="146"> Performance is slightly slower, but only pre-processing performance is affected and not runtime performance.</s><s id="205" sid="147"> The fitting results for a dress model are shown in <xref ref-type="fig" rid="F5" id="206" class="deo:Reference">Figure 5</xref>.</s><s id="207" sid="148"> Notably, the floating regions (colored in red in <xref ref-type="fig" rid="F5(d" id="208" class="deo:Reference">Figure 5(d)</xref>) are attached to the root of the character, as shown in <xref ref-type="fig" rid="F5(b)" id="209" class="deo:Reference">Figure 5(b)</xref>; this is contributable to the fact that these regions are large in volume and they rarely collide with limbs during the walk motion.</s><marker type="block"/> <s id="218" sid="149">The residual values of the fitting provide useful information on how the garments behave in relation to the body.</s><s id="219" sid="150"> Intuitively, floating garments such as a skirt, cloth patches may collide with several joints; collisions need to be computed on these regions.</s><s id="220" sid="151"> On the other hand, the local movements of some cloth patches (like underwear) are negligible and these patches can be considered as being attached rigidly to the skeleton.</s><s id="221" sid="152"> In our approach,<marker type="column" number="2"/><marker type="block"/> three regions are identified from the residual values of the skin fitting process (<xref ref-type="fig" rid="F5(d)" id="223" class="deo:Reference">Figure 5(d)</xref>): those that potentially interact with several joints, those that are loosely attached to the skeleton and those that are rigidly attached to the skeleton.</s><s id="224" sid="153"> The threshold values are chosen in a way that the coarse mesh deformation remains sufficiently close to the pre-simulated sequence.</s><s id="225" sid="154"> For example, a false assignment of loose region into tight region would produce elongated deformations instead of slipping garment over the skin, and therefore generate an overly deformed coarse mesh, which is beyond the training data of the wrinkle generator.</s><s id="226" sid="155"> Similarly, a false assignment of region 3 into region 2 would result in the garment crossing the legs.</s><s id="227" sid="156"> In practice, values of 0.5 cm and 4.0 cm are used to identify tight regions and floating regions, respectively.</s><s id="228" sid="157"> The deformation of tight regions is directly computed with the SDD (line 2 and 6 on <xref ref-type="fig" rid="F6" id="229" class="deo:Reference">Figure 6</xref>).</s><s id="230" sid="158"> The use of SDD for these regions makes it possible to reduce the number of mass points even further.</s><s id="231" sid="159"> The pseudo code of the simulation loop is: 1 for each vertex P ∈ Coarse_Mesh do 2 M SDD ← SDD P (Skeleton_Joint_Angles) 3 if P ∉ Tight_Region 4 X P ← Mass_Spring_system(time_step) 5 else 6 X P ← M SDD .X D,Dress //Skeleton Driven Deformation<marker type="block"/> High residual values indicate much less dependency on a specific body region of the cloth movement.</s><s id="236" sid="160"> Therefore, an additional collision check is required to handle the interaction of the clothes with the whole body skeleton.</s><s id="237" sid="161"> A list of potentially colliding body patches is defined by selecting those that approach within a certain distance of the floating regions during the pre-simulated cloth sequence.</s><s id="238" sid="162"> Apart from the position, our SDD computes the local transformation matrix of the vertices, the simulator to be optimized at least for the two following points: limiting collision checks to a small area around the vertices, and the geometric wrinkling which is processed in the SDD local coordinate system.</s></region>
          <region class="unknown" id="211" page="5" column="1">Residual Value (cm)</region>
          <region class="DoCO:FigureBox" id="Fx212">
            <image class="DoCO:Figure" src="3wxs.page_005.image_08.png" thmb="3wxs.page_005.image_08-thumb.png"/>
            <image class="DoCO:Figure" src="3wxs.page_005.image_09.png" thmb="3wxs.page_005.image_09-thumb.png"/>
            <image class="DoCO:Figure" src="3wxs.page_005.image_10.png" thmb="3wxs.page_005.image_10-thumb.png"/>
          </region>
          <region class="unknown" id="213" page="5" column="1">Identification of the garment regions Garments rigidly attached to the skeleton through SDD Garments for which the collision detection is made with collision hulls only Garments for which the collision detection is made with collision hulls and a predefined list of potentially colliding joints (d)</region>
          <region class="DoCO:FigureBox" id="F5">
            <image class="DoCO:Figure" src="3wxs.page_005.image_11.png" thmb="3wxs.page_005.image_11-thumb.png"/>
            <caption class="deo:Caption" id="217" page="5" column="1"><s id="215" sid="163">Figure 5.</s><s id="216" sid="164"> (a) and (b) influence of the joints on the dress shown in color, (c) quality of the fitting of the SDD data, (d) the three regions computed on an analysis of the residual values.</s></caption>
          </region>
          <region class="DoCO:FigureBox" id="F6">
            <caption class="deo:Caption" id="235" page="5" column="2"><s id="233" sid="165">Figure 6.</s><s id="234" sid="166"> The coarse mesh is computed with both mass-spring system and SDD.</s></caption>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="240" page="5" column="2">5.3. Data-driven post-correction of the coarse mesh</h2>
          <region class="DoCO:TextChunk" id="278" page="5" column="2"><s id="241" sid="167">At each frame of the simulation, we compute the coarse mesh by a mass-spring system with the implicit Euler numerical solver [<xref ref-type="bibr" rid="R2" id="242" class="deo:Reference">2</xref>].</s><s id="243" sid="168"> The simulation run on the coarse mesh hardly reproduces the gross movement of the original cloth because the initial mesh has been significantly simplified (from 4000 to a few dozen vertices) and the topology has been modified.</s><s id="244" sid="169"> Moreover, unlike the simulator used for the pre-simulated cloth<marker type="page" number="6"/><marker type="column" number="1"/><marker type="block"/> sequence, the simplified mass-spring model does not accurately simulate the bending and shearing properties of the fabrics [21].</s><marker type="block"/> <s id="251" sid="170">We approach the problem by modifying the behavior of the mass-spring system through a fix-up process (similar to [14]) where the position and velocity of the coarse mesh vertices are modified in order to maintain the cloth shape as close as possible to the original one (<xref ref-type="fig" rid="F7" id="252" class="deo:Reference">Figure 7</xref>).</s><s id="253" sid="171"> X N,Pre-computed X P,Pre-computed Neighbor's positions Vertex positions Frame 1 ... Frame n ...</s><marker type="block"/> <s id="260" sid="172">Ideally, the local shape (e.g.</s><s id="261" sid="173"> position of the vertices in relation to their neighbors) should be a blend of those of the pre-simulated animation.</s><s id="262" sid="174"> This is achieved by constructing a set of functions of local shape deformation.</s><s id="263" sid="175"> Post-correction is accomplished with a function that evaluates the "ideal" position of the vertex given the position of its neighbors connected by the edges.</s><s id="264" sid="176"> For each vertex, we construct an interpolating function F Post by using a set of (X N,Pre-simulated , X P,Pre-simulated ) pairs extracted from each frame of the pre-simulated sequence, where X N ∈R 3 (n: number of neighbors of P) denotes the position of the neighbors and X N ∈R 3n the position of the vertex in question.</s><s id="265" sid="177"> All these positions are described in the SDD coordinate system of P. The evaluation of the "ideal" position is made with the inverse distance weighting on the pre-simulated frames.</s><s id="266" sid="178"> Given a position<marker type="column" number="2"/><marker type="block"/> of neighbors X N,Input as input, the interpolation computes the corresponding X P by a weighted summation of the X P,pre-simulated values, each weight being computed from the Euclidian distance between X N,Input and all the X N,Pre- simulated values.</s><s id="268" sid="179"> The computation cost of this interpolator grows as the number of pre-simulated frames increases.</s><s id="269" sid="180"> We wish to keep the computation cost constant regardless of the duration of the pre-simulated sequence.</s><s id="270" sid="181"> A common solution is to construct a lookup table filled with values pre-simulated by the interpolator on grid sampling.</s><s id="271" sid="182"> In order to reduce the memory usage of the lookup table, the dimension of XN,Pre-simulated was reduced prior to the construction of the interpolator, by Principal Component Analysis [16].</s><s id="272" sid="183"> The first three principal components, which describe 95 % of the average variability of the data, are used.</s><s id="273" sid="184"> The positions of the vertices are corrected after every simulation loop.</s><s id="274" sid="185"> The velocity is updated as well.</s><s id="275" sid="186"> Its new value is set to the sum of the original velocity and the velocity due to the modification of the vertex position (line 11 on <xref ref-type="fig" rid="F9" id="276" class="deo:Reference">Figure 9</xref>).</s><s id="277" sid="187"> 7 X’ P ← X P 8 for each vertex P ∈ Coarse_Mesh do 9 if P ∉ Tight_Region 10 X P ← F Post (X’ P , M SDD ) 11 V P ← V P + (X’ P – X P ) / time_step</s></region>
          <region class="unknown" id="247" page="6" column="1">t 1 t 2 t 3 t 4 t 1 t 3 t 2 t 4 t 1 t 2 t 3 t 4 Simulation before post- Simulation after post- Pre-computed frames correction correction</region>
          <region class="DoCO:FigureBox" id="F7">
            <caption class="deo:Caption" id="250" page="6" column="1"><s id="248" sid="188">Figure 7.</s><s id="249" sid="189"> Post-correction of the mass-spring system.</s></caption>
          </region>
          <region class="unknown" id="255" page="6" column="1">Dimension reduction by PCA Construction of the inverse distance weighting interpolator X P =F DD (X N ) Values Lookup table of F Post generated according to a regular grid X N,1 , X N,2 , X N,3 ... X P,1 , X P,2 , X P,3 ...</region>
          <region class="DoCO:FigureBox" id="F8">
            <image class="DoCO:Figure" src="3wxs.page_006.image_12.png" thmb="3wxs.page_006.image_12-thumb.png"/>
            <caption class="deo:Caption" id="259" page="6" column="1"><s id="257" sid="190">Figure 8.</s><s id="258" sid="191"> Construction of the lookup table for the data- driven post-correction.</s></caption>
          </region>
          <region class="DoCO:FigureBox" id="F9">
            <caption class="deo:Caption" id="281" page="6" column="2"><s id="279" sid="192">Figure 9.</s><s id="280" sid="193"> Post-correction of the mass-spring system.</s></caption>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="282" page="6" column="2">5.4. Collision hulls</h2>
          <region class="DoCO:TextChunk" id="314" page="6" column="2"><s id="283" sid="194">To prune unnecessary collision tests, we pre-compute what we term “collision hulls” that exploit the skin-to- cloth relation obtained from the pre-simulated sequence.</s><s id="284" sid="195"> These are built once at the beginning of the simulation (prior to the runtime simulation) after the SDD has been computed on the coarse mesh, using the pre-simulated sequence.</s><s id="285" sid="196"> At each pre-simulated frame, we calculate the difference between the SDD motion model and the pre- simulated cloth model in the local coordinate system of the SDD.</s><s id="286" sid="197"> After a sweep, we get a set of points that cover the path a patch takes during the simulation.</s><s id="287" sid="198"> The smallest convex hull that contains all these points is generated for every patch using the “Quickhull” algorithm presented by Barber et al [<xref ref-type="bibr" rid="R3" id="288" class="deo:Reference">3</xref>].</s><s id="289" sid="199"> Given enough variation and range of character motion, we expect these hulls to cover the allowable positions of corresponding cloth patches during the runtime simulation.</s><s id="290" sid="200"> By using collision hulls, collision tests are restricted to a small area around the patch; the overall computation can be significantly reduced in comparison to classical collision detection methods in which collisions are computed between the whole skin and cloth surface.</s><s id="291" sid="201"> Note that the collision hulls are generated for loose and floating garment regions only.</s><marker type="page" number="7"/><marker type="column" number="1"/><marker type="block"/> <s id="293" sid="202">The collision hulls of tight regions are small enough to be approximated by a single point.</s><s id="294" sid="203"> <xref ref-type="fig" rid="F10(d)" id="295" class="deo:Reference">Figure 10(d)</xref> shows the convex hulls computed for the dress model.</s><marker type="block"/> <s id="303" sid="204">Collision handling at runtime consists of correcting the position of coarse mesh vertices after every simulation step so that they remain inside their respective hulls.</s><s id="304" sid="205"> The algorithm is summarized as follows: 12 for every vertex P ∈ Coarse_Mesh do 13 if P ∉ Tight_Region 14 if X p ∉ Collion_Hull(M SDD ) 15 Collision_Response with Collion_Hull<marker type="block"/> Thus, collision detection returns to computing if the particle is in its associated collision hull (line 14 on <xref ref-type="fig" rid="F11" id="309" class="deo:Reference">Figure 11</xref>); the Gilbert-Johnson-Keerthi algorithm [<xref ref-type="bibr" rid="R8" id="310" class="deo:Reference">8</xref>] is ideally suited to this task.</s><s id="311" sid="206"> We used constrained dynamics [22] to handle the collision response (i.e.</s><s id="312" sid="207"> modification of position and velocity in response to collision detection) at line 15.</s><s id="313" sid="208"> Collision detection is also computed between floating regions and skeleton joints as follows: 16 for each edge e ∈ Coarse_Mesh do 17 if e ∈ Floating_Region 18 if Collision(e, body_segment) 19 Collision_Response with body_segment</s></region>
          <region class="DoCO:FigureBox" id="Fx297">
            <image class="DoCO:Figure" src="3wxs.page_007.image_13.png" thmb="3wxs.page_007.image_13-thumb.png"/>
          </region>
          <region class="unknown" id="298" page="7" column="1">(b) (c)</region>
          <region class="DoCO:FigureBox" id="F10">
            <image class="DoCO:Figure" src="3wxs.page_007.image_14.png" thmb="3wxs.page_007.image_14-thumb.png"/>
            <caption class="deo:Caption" id="302" page="7" column="1"><s id="300" sid="209">Figure 10.</s><s id="301" sid="210"> Computation of the collision hull for each cloth patch; (a): residual values of SDD attachment fitting, (b): computation of local cloth displacement, (c): convex hulls covering all displacements, (d): resulting collision hulls.</s></caption>
          </region>
          <region class="DoCO:FigureBox" id="F11">
            <caption class="deo:Caption" id="308" page="7" column="1"><s id="306" sid="211">Figure 11.</s><s id="307" sid="212"> Collision handling using collision hulls (loose and floating regions).</s></caption>
          </region>
          <region class="DoCO:FigureBox" id="F12">
            <caption class="deo:Caption" id="317" page="7" column="1"><s id="315" sid="213">Figure 12.</s><s id="316" sid="214"> Collision handling on floating regions.</s></caption>
          </region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="318" page="7" column="1">5.5. Runtime computations</h2>
          <region class="DoCO:TextChunk" id="326" page="7" column="1"><s id="319" sid="215">The real-time computation of global cloth movements is obtained with a mass-spring system together with the collision response and post-correction described above.</s><s id="320" sid="216"> The runtime computation of the coarse mesh is obtained in the following order: • Mass-spring computation (<xref ref-type="fig" rid="F6" id="321" class="deo:Reference">Figure 6</xref>) • Post-correction (<xref ref-type="fig" rid="F9" id="322" class="deo:Reference">Figure 9</xref>) • Collision response on hulls (<xref ref-type="fig" rid="F11" id="323" class="deo:Reference">Figure 11</xref>)<marker type="column" number="2"/><marker type="block"/> • Collision response on floating garments (<xref ref-type="fig" rid="F12" id="325" class="deo:Reference">Figure 12</xref>) Note that the collision response on floating garments comes last to ensure collision avoidance between cloth and body.</s></region>
        </section>
      </section>
      <section class="DoCO:Section">
        <h1 class="DoCO:SectionTitle" id="327" page="7" column="2">6. Generating garment details</h1>
        <region class="DoCO:TextChunk" id="361" page="7" column="2"><s id="328" sid="217">So far we have shown the first part of our simulation, that is, the coarse level simulation.</s><s id="329" sid="218"> We continue now to describe the second part of the simulation, by which detailed cloth shape such as wrinkles or folds are depicted.</s><s id="330" sid="219"> Again, the main challenge here is obtaining the highest possible realism while maintaining acceptable computation load, in order to meet the real-time requirements.</s><s id="331" sid="220"> As recognized in earlier works [9] [13], wrinkles can be efficiently animated with a geometric method as they are geometric in nature.</s><s id="332" sid="221"> Unlike previous methods, however, our wrinkling function is not hand-drawn, nor geometrically approximated, but rather trained from on the analysis of the pre-simulated sequence.</s><s id="333" sid="222"> In this work, we choose to represent the wrinkle displacement in the local coordinate system used for SDD.</s><s id="334" sid="223"> This makes our wrinkle parameterization invariant of all joints of higher hierarchy than the currently influencing joint.</s><marker type="block"/> <s id="344" sid="224">Several techniques exist for shape interpolation using examples, such as Radial Basis Functions or parametric interpolation.</s><s id="345" sid="225"> We have used linear interpolation in which coefficients are defined by multi-linear regression on the pre-simulated animation, since it provides satisfactory results at a very low computation cost.</s><s id="346" sid="226"> For every vertex x in a patch, the interpolator function takes the associated mass point in the coarse mesh, and its neighbors as input.</s><s id="347" sid="227"> To calculate the position of x from the input, the wrinkle interpolator interpolates the positions of the coarse mesh<marker type="page" number="8"/><marker type="column" number="1"/><marker type="block"/> points, weighted by coefficients determined the regression model of the following form: Error!</s><s id="349" sid="228"> Objects cannot be created from editing field codes.</s><s id="350" sid="229"> The values α, α P and α N are the interpolation coefficients.</s><s id="351" sid="230"> They are defined by multi-linear regression on a set of pairs (positions of coarse mesh vertices, fine mesh vertices) extracted from the pre-simulated cloth sequence.</s><s id="352" sid="231"> X P and X N are respectively the position of the vertex x and its neighbors; they are all expressed in the SDD coordinate system of x.</s><s id="353" sid="232"> Despite its simplicity, linear interpolation works fairly well provided a sufficient number of pre-simulated frames for the multi-linear regression.</s><s id="354" sid="233"> A condition of a good working interpolator is that the input (i.e.</s><s id="355" sid="234"> position of the coarse mesh vertices) should be within the range of the pre-simulated data.</s><s id="356" sid="235"> In other word, the wrinkle interpolator can only work for the input range for which it has been trained.</s><s id="357" sid="236"> This condition is maintained thank to the data-driven post-correction (see Section 5.3).</s><s id="358" sid="237"> This also keeps the smoothness of the boundaries between patches.</s><s id="359" sid="238"> <xref ref-type="fig" rid="F14" id="360" class="deo:Reference">Figure 14</xref> illustrates the deformation of the wrinkles.</s></region>
        <region class="unknown" id="336" page="7" column="2">Coarse Mesh Frame</region>
        <region class="unknown" id="337" page="7" column="2">N 1</region>
        <region class="DoCO:FigureBox" id="Fx338">
          <image class="DoCO:Figure" src="3wxs.page_007.image_15.png" thmb="3wxs.page_007.image_15-thumb.png"/>
          <image class="DoCO:Figure" src="3wxs.page_007.image_16.png" thmb="3wxs.page_007.image_16-thumb.png"/>
        </region>
        <region class="unknown" id="339" page="7" column="2">Main control point Neighbors Patch of a fine mesh</region>
        <region class="DoCO:FigureBox" id="F13">
          <image class="DoCO:Figure" src="3wxs.page_007.image_18.png" thmb="3wxs.page_007.image_18-thumb.png"/>
          <caption class="deo:Caption" id="343" page="7" column="2"><s id="341" sid="239">Figure 13.</s><s id="342" sid="240"> Shape of the patch with respect to the positions of the control point P and its neighbors N1, N2, and N3.</s></caption>
        </region>
        <region class="DoCO:FigureBox" id="F14">
          <image class="DoCO:Figure" src="3wxs.page_008.image_19.png" thmb="3wxs.page_008.image_19-thumb.png"/>
          <caption class="deo:Caption" id="365" page="8" column="1"><s id="363" sid="241">Figure 14.</s><s id="364" sid="242"> The wrinkling interpolator in action: wrinkles in (b) and (d) are generated geometrically with (a) and (c) as input.</s></caption>
        </region>
      </section>
      <section class="deo:Results">
        <h1 class="DoCO:SectionTitle" id="366" page="8" column="1">7. Results and Discussion</h1>
        <region class="DoCO:TextChunk" id="369" page="8" column="1"><s id="367" sid="243">We measure and validate the proposed real-time cloth simulation method along three criteria: the variety of clothes to be simulated, the computation speed and the range of body motion in the pre-simulated cloth sequence.</s><s id="368" sid="244"> Pre-simulated sequences obtained by the cloth simulator of Volino et al [21] were used in our preprocessing.</s></region>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="370" page="8" column="1">7.1. Variety of clothes</h2>
          <region class="DoCO:TextChunk" id="391" page="8" column="1"><s id="371" sid="245">We used our framework to different types of clothes, as shown on the demonstration video.</s><s id="372" sid="246"> • The “evening” dress (<xref ref-type="fig" rid="F14" id="373" class="deo:Reference">Figure 14</xref>) is chosen to demonstrate our wrinkle interpolator on large garment regions.</s><s id="374" sid="247"> • The “cocktail” dress (<xref ref-type="fig" rid="F18" id="375" class="deo:Reference">Figure 18</xref>) is a relatively complex model; the bottom is composed of two layers of<marker type="column" number="2"/><marker type="block"/> tissues and has folds made of large number of vertices, inducing many self collisions.</s><s id="377" sid="248"> • The “Jeans” outfit is a good example of a model where the SDD based geometric approximation can reduce the number of mass points substantially by simulating only a few regions that contribute significantly to the dynamic behavior.</s><s id="378" sid="249"> Our simulator behaves fairly well on a wide variety of clothes, including those with highly stiff mechanical properties.</s><s id="379" sid="250"> <xref ref-type="fig" rid="F18" id="380" class="deo:Reference">Figure 18</xref> show the pre-processing and runtime simulation results for the cocktail dress.</s><s id="381" sid="251"> Moreover, performance will increase due to the fact that the smallest number of triangles will be processed for the real-time rendering.</s><s id="382" sid="252"> However, the method may introduce flaws in simulation for some tight clothes, due to the approximate handling of collision detection.</s><s id="383" sid="253"> For some body movements, the skin surface may slightly intersect the cloth surface.</s><s id="384" sid="254"> Similarly, the same problem may arise for self-collisions on clothes.</s><s id="385" sid="255"> The deletion of the skin triangles covered by the garment surface can partially correct this drawback.</s><s id="386" sid="256"> Note that the cloth simulation is also restricted to clothes worn on bodies.</s><s id="387" sid="257"> While offering high computation speed, the cloth simulator cannot handle some cloth movements such as those appearing during dressing or undressing.</s><s id="388" sid="258"> More generally, the clothes are unable to interact with objects other than those that have been taken into consideration during the pre-processing phase.</s><s id="389" sid="259"> The list of objects that can potentially interact with clothes and the way these objects interact are defined at the preprocessing stage and cannot be changed during the real- time simulation.</s><s id="390" sid="260"> Finding a method to update the list of possible interacting objects automatically could be a subject for future research.</s></region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="392" page="8" column="2">7.2. Variety of clothes</h2>
          <region class="DoCO:TextChunk" id="397" confidence="possible" page="8" column="2"><s id="393" sid="261"> <xref ref-type="fig" rid="F15" id="394" class="deo:Reference">Figure 15</xref> summarizes the performance of our simulator on a 1 GHz Windows PC.</s><s id="395" sid="262"> Evening Jeans Cocktail Dress Outfit Dress Number of faces 2992 2131 1331 Pre-processing time (min.)</s><s id="396" sid="263"> 8 8 7 Number of vertices on the rough mesh 110 97 82 Time performance of coarse mesh (fps) 31 63 74 Time performance of the fine mesh (fps) 207 322 588 Overall Performance (fps) 26 51 63</s></region>
          <region class="DoCO:FigureBox" id="F15">
            <caption class="deo:Caption" id="400" page="8" column="2"><s id="398" sid="264">Figure 15.</s><s id="399" sid="265"> Computation speed.</s></caption>
          </region>
          <region class="DoCO:TextChunk" id="406" page="8" column="2"><s id="401" sid="266">The pre-processing of all the cloth models took less than 10 minutes.</s><s id="402" sid="267"> All examples run in real-time at approximately 25 to 50 frames per second (fps), with the coarse mesh deformation process taking about 75 % of the total CPU time.</s><s id="403" sid="268"> As expected, the duration of the pre-<marker type="page" number="9"/><marker type="column" number="1"/><marker type="block"/> simulated sequence is not a factor of the runtime computation speed.</s><s id="405" sid="269"> In practice, the performance lowers down at a low rate as the complexity of the collision hulls increases, which tends to be governed by the number of pre-simulated frames (see Section 5.3).</s></region>
        </section>
        <section class="DoCO:Section">
          <h2 class="DoCO:SectionTitle" id="407" page="9" column="1">7.3. Variety of clothes</h2>
          <region class="DoCO:TextChunk" id="428" page="9" column="1"><s id="408" sid="270">As expected, the quality of the simulation depends on the number and variety of examples – the pre-simulated sequence in our case.</s><s id="409" sid="271"> To show that the simulator faithfully recreates the cloth movement used for training, we compared the real-time simulation with the pre- simulated one in the first video.</s><s id="410" sid="272"> The character walks at a normal pace without any fast movements.</s><s id="411" sid="273"> In the second video, different body movements from those of the training were supplied as input to our real- time simulator and the results are compared with the ones generated with a high quality simulator.</s><marker type="block"/> <s id="417" sid="274">To measure the simulation quality, we compared our simulation results with the pre-simulated sequence, using a deformation metric.</s><s id="418" sid="275"> It measures the still shape and movement by the sum of edge length difference and the mass velocity difference over the cloth mesh.</s><s id="419" sid="276"> The <xref ref-type="fig" rid="F16" id="420" class="deo:Reference">Figure 16</xref> shows the importance of the variability of the body motion in the pre-simulated sequence.</s><s id="421" sid="277"> The best quality is achieved when the range of the body motion in the pre- simulated sequence is approximately 30 % larger than the one used in the real-time simulation.</s><s id="422" sid="278"> Our simulator works well for interpolation (i.e.</s><s id="423" sid="279"> joint angles within the range of those of the pre-simulated sequence) but often fails for extrapolation.</s><s id="424" sid="280"> The main reason for this limitation is collision detection, which does not allow the clothes to have different locations on the body from those calculated in the pre-simulated sequence; this makes the clothes being attached rigidly to the skeleton.</s><s id="425" sid="281"> The <xref ref-type="fig" rid="F17" id="426" class="deo:Reference">Figure 17</xref> shows the effect of using motion of different durations (expressed in number of frames) with same joint angle ranges.</s><s id="427" sid="282"> With less than 70 pre-simulated frames, the real-time simulation loses its quality.</s></region>
          <region class="unknown" id="413" page="9" column="1">100 cm in error 10 Simulation 6.34 0 0.2 0.4 0.6 0.8 1 1.2 1.4 1.6 Joint angle range of the pre-simulated sequence Ratio of Joint angle range of the real-time sequence</region>
          <region class="DoCO:FigureBox" id="F16">
            <caption class="deo:Caption" id="416" page="9" column="1"><s id="414" sid="283">Figure 16.</s><s id="415" sid="284"> Estimation of the error when reducing the range of body motion in the pre-simulated sequence.</s></caption>
          </region>
          <region class="unknown" id="429" page="9" column="2">cm 100 in error Simulation 6.34 10 0 20 40 60 80 100 Number of pre-simulated frames</region>
          <region class="DoCO:FigureBox" id="F17">
            <caption class="deo:Caption" id="432" page="9" column="2"><s id="430" sid="285">Figure 17.</s><s id="431" sid="286"> Estimation of the error when reducing the number of pre-simulated frames.</s></caption>
          </region>
        </section>
      </section>
      <section class="deo:Conclusion">
        <h1 class="DoCO:SectionTitle" id="433" page="9" column="2">8. Conclusion</h1>
        <region class="DoCO:TextChunk" id="447" page="9" column="2"><s id="434" sid="287">The recent advent of cloth simulation techniques has matured enough to produce highly realistic cloth movements on animated characters.</s><s id="435" sid="288"> However, real-time simulation has been largely unexplored until now.</s><s id="436" sid="289"> This paper presents the first report of a practical and efficient method for handling real-time simulation almost automatically.</s><s id="437" sid="290"> We used our framework to produce visually pleasing motion of a wide range of clothes.</s><s id="438" sid="291"> Both the mass-spring system and collision detection have been rewritten to take advantage of the pre-simulated sequence of the clothes to be animated.</s><s id="439" sid="292"> Consequently, our cloth simulator is able to construct a model for real-time animation without user intervention and can deal with different types of clothes from tight to floating with low computation consumption.</s><s id="440" sid="293"> There are many interesting avenues for future work.</s><s id="441" sid="294"> First, the approach could be extended to simulating other physics-based models such as hair and fluid.</s><s id="442" sid="295"> We also believe that the work on collision hulls is promising.</s><s id="443" sid="296"> The current mesh model of collision hulls could be replaced by implicit surfaces or voxel maps.</s><s id="444" sid="297"> Therefore, for a cloth vertex, it could be possible to compute several collisions hulls in relation to different objects in the scene and to compute their intersection for real-time collision detection.</s><s id="445" sid="298"> By doing so, it may be possible to process collisions on a higher number of objects while maintaining low computation cost.</s><s id="446" sid="299"> We also believe that the precision of the collision detection could be improved by replacing the convex shape by a surface to follows more closely the trajectories of the vertices.</s></region>
      </section>
      <section class="deo:Acknowledgements">
        <h1 class="DoCO:SectionTitle" id="448" page="9" column="2">9. Acknowledgements</h1>
        <region class="DoCO:TextChunk" id="451" page="9" column="2"><s id="449" sid="300">This work is supported by the Swiss National Science Foundation (SNSF).</s><s id="450" sid="301"> Thanks to Marlène Arévalo and Christiane Luible for their design work to the garment models illustrating this paper.</s></region>
      </section>
      <section class="DoCO:Bibliography">
        <h1 class="DoCO:SectionTitle" id="452" page="10" column="1">10. References</h1>
        <ref-list class="DoCO:BiblioGraphicReferenceList">
          <ref rid="R1" doi="http://dx.doi.org/10.1145/235815.235821" confidence="possible" class="deo:BibliographicReference" id="453" page="10" column="1">
		  <region class="Bibliographic" id="1">[1] Alexa, M., "Linear Combination of Transformations", SIGGRAPH 2002 Conference Proceedings, Annual Conference Series, ACM Press, Vol. 21(3), pp. 380-387, 2002.</region>-<abstract class="DoCO:Abstract" id="39" confidence="possible"><s id="2" sid="1">[2] Baraff D., Witkin, A., "Large steps in cloth simulation", ACM Transactions on Graphics, Proceedings of ACM SIGGRAPH, ACM Press, pp.</s><s id="3" sid="2"> 43-54, 1998.</s><s id="4" sid="3"> [3] Barber C. B., Dobkin D.P., Huhdanpaa H.T., "The Quickhull Algorithm for Convex Hulls", ACM Transactions on Mathematical Software, ACM Press, Vol.</s><s id="5" sid="4"> 22(4), pp.</s><s id="6" sid="5"> 469-483, 1996.</s><s id="7" sid="6"> [4] Burden R. L., Faires J. D., "Numerical Analysis, Fifth Edition", PWS Publishing, ISBN 0-534-93219-3, 1993.</s><s id="8" sid="7"> [5] Cordier F., Magnenat-Thalmann N., "Real-time Animation of Dressed Virtual Humans", Eurographics, Blackwell publishers, Vol.</s><s id="9" sid="8"> 21(3), pp 327-336, 2002.</s><s id="10" sid="9"> [possible DOI] [6] Choi K.-J., Ko H.-S., "Stable but Responsive Cloth", ACM Transactions on Graphics, Proceedings of ACM SIGGRAPH 2002, ACM Press, Vol.</s><s id="11" sid="10"> 21(3), pp.</s><s id="12" sid="11"> 604-611, 2002.</s><s id="13" sid="12"> [7] Desbrun M., Schröder P., Barr A. H. "Interactive Animation of Structured Deformable Objects", In Graphics [possible DOI] [alternative DOI] Interface'99 proceedings, Morgan Kaufmann, pp.</s><s id="14" sid="13"> 1-8, 1999.</s><s id="15" sid="14"> [possible DOI] [8] Gilbert E. G., Johnson D.W., Keerthi S. S., "A fast procedure for computing the distance between complex objects in three-dimensional space", IEEE Journal of Robotics and Automation, IEEE Press, Vol.</s><s id="16" sid="15"> 4(2), pp.</s><s id="17" sid="16"> 193-203, 1988.</s><s id="18" sid="17"> [9] Hadap S., Bangarter E., Volino P., Magnenat-Thalmann N., "Animating Wrinkles on Clothes", IEEE Visualization '99, San Francisco, USA, IEEE Press, pp.</s><s id="19" sid="18"> 175-182, 1999.</s><s id="20" sid="19"> [10] James D. L., Fatahalian K., "Precomputing Interactive Dynamic Deformable Scenes", ACM Transactions on Graphics, ACM Press, Vol.</s><s id="21" sid="20"> 22(3), pp.</s><s id="22" sid="21"> 165-172, 2003.</s><s id="23" sid="22"> [11] Kacic-Alesic Z., Nordenstam M., Bullock D., "A practical dynamics system", ACM SIGGRAPH/Eurographics Symposium on Computer Animation, ACM Press, pp.</s><s id="24" sid="23"> 7-16, 2003.</s><s id="25" sid="24"> [possible DOI] [alternative DOI] [12] Kang Y.-M., Cho H.-G., "Bilayered Approximate Integration for Rapid and Plausible Animation of Virtual Cloth with Realistic Wrinkles", Computer Animation 2002, Switzerland, IEEE Press, pp.</s><s id="26" sid="25"> 203-214, 2002.</s><s id="27" sid="26"> [13] Kang Y.-M., Choi J.-H., Cho H.-G., Lee D.-H., "An efficient animation of wrinkled cloth with approximate implicit integration", The Visual Computer Journal, Spinger-Verlag, Vol.</s><s id="28" sid="27"> 17(3), pp.</s><s id="29" sid="28"> 147-157, 2001.</s><s id="30" sid="29"> [14] Meyer M., Debunne G., Desbrun, M., Barr A. H., "Interactive Animation of Cloth-like Objects in Virtual Reality", Journal of Visualization and Computer Animation, John Wiley & Sons, Vol.</s><s id="31" sid="30"> 12(1), pp.</s><s id="32" sid="31"> 1- 12, 2001.</s><s id="33" sid="32"> [15] Mohr A., and Gleicher M., "Building Efficient, Accurate Character Skins from Examples", ACM Transactions on Graphics, ACM Press, Vol.</s><s id="34" sid="33"> 22(3), pp.</s><s id="35" sid="34"> 165-172, 2003.</s><s id="36" sid="35"> [16] Press W. H., Flannery B. P., Teukolsky S. A., and Vetterling, W. T., “Numerical Recipes in C, The art of scientific computing”, Cambridge University Press, pp.</s><s id="37" sid="36"> 412-420, 1988.</s><s id="38" sid="37"> [17] Provot, X., "Deformation Constraints in a Mass-Spring Model to Describe Rigid Cloth Behavior", Graphics Interface'95 proceedings, A K Peters, pp 147-154, 1995.</s></abstract>-<region class="DoCO:TextChunk" id="42"><s id="40" sid="38">[18] Rudomin, I., Meln, M., "Multi-Layer Garments Using Hybrid Models", Visual 2000, Springer, pp.</s><s id="41" sid="39"> 118, 2000.</s></region>-<region class="DoCO:TextChunk" id="48" confidence="possible"><s id="43" sid="40">[19] Terzopoulos D., Fleischer K., "Deformable Models", The Visual Computer, Springler-Verlag, Vol.</s><s id="44" sid="41"> 4(6), pp.306-331, 1988.</s><s id="45" sid="42"> [20] Vassilev T., Spanlang B., "Fast Cloth Animation on Walking Avatars", Eurographics, Blackwell Publishers, Vol.</s><s id="46" sid="43"> 20(3), pp.</s><s id="47" sid="44"> 260-267, 2001.</s></region>-<region class="DoCO:TextChunk" id="52"><s id="49" sid="45">[21] Baraff D., Witkin A. P., Kass M., "Untangling cloth", ACM Transaction on Graphics, ACM Press, Vol.</s><s id="50" sid="46"> 22(3), pp.</s><s id="51" sid="47"> 862-870, 2003.</s></region>-<region class="DoCO:TextChunk" id="56" confidence="possible"><s id="53" sid="48">[22] Bridson R., Fedkiw R., Anderson J., "Robust treatment of collisions, contact and friction for cloth animation", ACM Transactions on Graphics, vol.</s><s id="54" sid="49"> 21(3), ACM Press, pp.</s><s id="55" sid="50"> 594-603, 2003.</s></region>
		  </ref>
		</ref>  
      </section>
    </body>
  </article>
</pdfx>
